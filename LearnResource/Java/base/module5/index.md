# 面向对象

面向过程
![](assets/chemistry.jpg)

面向对象
![](assets/blackBox.jpg)

这个大方盒子里存放着函数和变量
(那些化学仪器 试管 烧杯 等等)
这些元素对于用户却是不可见的

## 对象的概念
客观世界
映射
面向对象的程序设计中
把问题域中的事物抽象成对象(Object)
事物的静态特征（属性）用一组数据来描述
事物的动态特征（行为）则用一组方法来刻划。

## 抽象
舍弃个别
舍弃非本质

## 过程抽象
软件开发中可以把一个复杂的功能分解为一些子功能（模块）

## 数据抽象
处理的数据和施加于这些数据之上的操作结合在一起
根据功能、性质、作用等因素抽象成不同的抽象数据类型。
每个抽象数据类型既包含了数据，也包含了针对这些数据的授权操作，并限定数据的值只能由这些操作来观察和修改。

## 类的概念
抽象和归纳
本质特征(关注)
非本质特征(不关注)
共性

![](assets/clazz.jpg)

## 什么是对象的属性
对象有什么

## 什么是对象的方法
对象能干什么(执行的操作)

## 类与对象的关系/区别
类是抽象的概念,仅仅是模板
对象是一个可以看得到,摸得着的具体实体

## 面向对象与面向过程的区别
    面向过程
    优点：性能比面向对象高，因为类调用时需要实例化，开销比较大，比较消耗资源;比如单片机、嵌入式开发、Linux/Unix等一般采用面向过程开发，性能是最重要的因素。
    缺点：没有面向对象所拥有的易维护、易复用、易扩展
    面向对象
    优点：易维护、易复用、易扩展，由于面向对象有封装、继承、多态性的特性，可以设计出低耦合的系统，使系统更加
    灵活、更加易于维护
    缺点：性能比面向过程低
## 定义类

类的重要性
    所有的java程序都以类class为组织单元
类的组成
    属性与方法
定义一个类的步骤
  a=>定义类名
  b=>编写类的属性
  c=>编写类的方法

使用对象的步骤
  创建对象 类名 对象名 = new 类名();

  使用对象 引用对象的属性  对象名.属性  phone.screen = 5;
          调用对象的方法  对象名.方法名()  phone.call();


成员变量 和 局部变量

# 成员变量
  在类中定义,用来描述对象将要有什么
# 局部变量
  在类的方法中,在方法中临时保存数据
## 成员/局部区别
  作用域
  初始值
  重名问题

##  封装
把客观事物封装成抽象的类
类可以把自己的数据和方法只让可信的类或者对象操作
对不可信的进行封装隐藏
封装分为属性的封装和方法的封装

##  继承
继承是类与类的一种关系,是一种"is a"的关系

方法的重写
如果子类对继承父类的方法不满意
是可以重写父类继承的方法的
当调用方法时会有限调用子类的方法

## 课后练习
某公司的雇员分为以下若干类：
Employee：这是所有员工总的父类，属性：员工的姓名和生日月份。
方法：getSalary(int month) 根据参数月份来确定工资，如果该月员工过生日，
则公司会额外奖励100元。
SalariedEmployee：Employee的子类，拿固定工资的员工。属性：月薪
HourlyEmployee：Employee的子类，按小时拿工资的员工，每月工作超出160
小时的部分按照1.5倍工资发放
属性：每小时的工资、每月工作的小时数
SalesEmployee：Employee的子类，销售人员，工资由月销售额和提成率决定
属性：月销售额、提成率
BasePlusSalesEmployee：SalesEmployee的子类，有固定底薪的销售人员，
工资由底薪加上销售提成部分     属性：底薪。

## 多态
对象具有多种形态
不同类的对象对同一消息做出响应
方法的重载
类的覆盖体现了多态

引用的多态 
父类的引用可以指向本类的对象
父类的应用可以指向子类的对象

方法的多态
创建本类对象时
调用方法为本类方法
创建子类对象时
调用方法为子类方法

引用类型转换

向上类型转换(隐式/自动类型转换)
小到大的转换
向下类型转换(强制类型转换)
大到小的转换

## instanceof关键字
判断某个对象是否为某个类/接口类型

## final关键字
final关键字可以修饰
类=>表示类不能被继
属性=>表示变量是一个常量
方法=>表示方法不能重写(覆盖)

## 抽象类
包含未实现方法的类被称为抽象类

[修饰符] abstract class 类名{
   [属性]
   [方法]}

## 应用场景
父类只知道子类该包含怎样的方法,但无法准确知道这些子类如何实现这些方法。
从多个具有相同特征的类中抽象出一个抽象类,以这个抽象类作为 子类的模板,从而避免了类设计的随意性。

## Practice
现在有Shape图形类
设计
Rectangle矩形
Circle圆形子类
图形的周长(perimeter)面积(area)

## 接口
规范
!内部数据
!实现细节

interface 接口名 [extends 父接口1,父接口2... ]{
   属性都是常量  自动加public static final  XXX xxx = x;
   方法都是抽象方法  自动加 abstract XXX xxx();}

## 使用接口
一个类可以实现一个或者多个接口
实现接口使用implements关键字

## java特性
单继承
多接口

![](assets/interface.png)

接口中的匿名内部类使用
IXXXX xx = new IXXXX(){
    @Override
    public void overrideMethod(){}};

