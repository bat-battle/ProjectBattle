/**
 *	TCP数据的读写
 *	对文件的读写操作read和write同样适用于socket
 *
 *	socket编程接口提供了几个专门用户socket数据读写的系统调用，其中对于TCP流数据读写的系统调用是：
 *	
 *	#include <sys/types.h>
 *	#include <sys/socket.h>
 *	ssize_t recv(int sockfd, void * buf, size_t len, int flags);
 *	ssize_t send(int sockfd, const void * buf, size_t len, int flags);
 *
 *	recv读取sockfd上的数据，buf和len参数分别指定读缓冲区的位置和大小，flags通常设置为0
 *	recv读取成功时返回实际读取到的数据的长度，它可能小于传入的len，所以我们可能要多次调用recv才能读取到完整数据
 *	recv返回0则代表通信对方已经关闭连接了
 * 	recv返回-1标示出错，测试会设置errno
 *
 *	send往sockfd上写入数据，buf和len指定写缓冲区的位置和大小，send成功时返回实际写入数据的长度，失败返回-1，并设置errno
 *
 *	flags参数为数据收发提供了额外的控制，包括以下几个值或者互相的或:
 *
 *  (因为要在注释中用到表格，所以生成了下面这样的表格，为此新写了一段脚本，可以在这里找到: https://github.com/linjunjie/shell_table.git
 *  目前生成的效果就是下面这样，我觉得这脚本肯定还有一段路要走...)
 * 
 * ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 * |  选项名         |  含义                                                                                                                                      |  send  |  recv  |
 * ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 * |  MSG_CONFIRM    |  指示数据链路层协议持续监听对方的回应，直到得到答复，它仅能用于SOCK_DGRAM和SOCK_RAW类型的socket                                            |  Y     |  N     |
 * ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 * |  MSG_DONTROUTE  |  不看路由表，直接将数据发送给本地局域网络内的主机，这表示发送者确切地知道目标主机就在本地网络上                                            |  Y     |  N     |
 * ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 * |  MSG_DONTWAIT   |  对socket的此次操作将是非阻塞的                                                                                                            |  Y     |  Y     |
 * ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 * |  MSG_MORE       |  告诉内核应用程序还有更多数据要发送，内核将超时等待新数据写入TCP发送缓冲区后一并发送，这样可以防止TCP发送过多小的报文段，从而提高传输效率  |  Y     |  N     |
 * ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 * |  MSG_WAITALL    |  读操作仅在读取到指定数量的字节后才返回                                                                                                    |  N     |  Y     |
 * ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 * |  MSG_PEEK       |  窥探缓存中的数据，此次读操作不会导致这些数据被清楚                                                                                        |  N     |  Y     |
 * ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 * |  MSG_OOB        |  发送或接收紧急数据                                                                                                                        |  Y     |  Y     |
 * ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 * |  MSG_NOSIGNAL   |  往读端关闭的管道或者socket接连中写数据时不引发SIGPIPE信号                                                                                 |  Y     |  N     |
 * ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 *
 *	顺便一提：flags参数只对send和recv的当前调用生效
 *
 *	使用方式:
 *	./testoobrecv 127.0.0.1 12345
 *	./testoobsend 127.0.0.1 12345
 *	sudo tcpdump -ntx -i eth0 port 12345
 *
 *	我本地机器的输出如下：
 *	got 3 bytes of normal data '123'
 *	got 1 bytes of oob data 'c'
 *	got 2 bytes of normal data 'ab'
 *
 */


#include "head.h"

int main(int argc, char * argv[]){
	if(argc <= 2){
		printf("usage : %s ip_address port_number\n", basename(argv[0]));
		return 0;
	}

	const char * ip = argv[1];
	int port = atoi(argv[2]);

	struct sockaddr_in server_address;
	bzero(&server_address, sizeof(server_address));
	server_address.sin_family = AF_INET;
	inet_pton(AF_INET, ip, &server_address.sin_addr);
	server_address.sin_port = htons(port);

	int sockfd = socket(PF_INET, SOCK_STREAM, 0);
	assert(sockfd >= 0);

	/**
	 *	#include <sys/types.h>
	 *	#include <sys/socket.h>
	 *	int connect(int sockfd, const struct sockaddr * serv_addr, socklen_t addrlen);
	 *	connect成功时返回0，一旦成功建立连接，sockfd就唯一地标识了这个连接，客户端就可以通过读写sockfd来与服务器通信
	 *	connect失败时返回-1并设置errno, 其中两种常见的errno是 ECONNREFUSED 和 ETIMEDOUT
	 *	其含义如下：（这里生成shell表使用到了之前提到的shell_table : https://github.com/linjunjie/shell_table.git）
	 * +----------------+------------------------------+
	 * |  ECONNREFUSED  |  目标端口不存在，连接被拒绝  |
	 * +----------------+------------------------------+
	 * |  ETIMEDOUT     |  连接超时                    |
	 * +----------------+------------------------------+
	 *
	 */
	if(connect(sockfd, (struct sockaddr *) &server_address, sizeof(server_address)) < 0){
		printf("connect failed\n");
	}else{
		const char * oob_data = "abc";
		const char * normal_data = "123";
		send(sockfd, normal_data, strlen(normal_data), 0);
		send(sockfd, oob_data, strlen(oob_data), MSG_OOB);
		send(sockfd, normal_data, strlen(normal_data), 0);
	}

	/**
	 *	close系统调用并非总是立即关闭一个连接，而是将fd的引用计数减1
	 *	只有当fd的引用计数为0时，才真正关闭连接。
	 *	在多进程程序中，一次fork系统调用默认将使父进程中打开的socket的引用计数加1，因此我们必须在父进程和子进程中都对该socket执行close调用才能将连接关闭
	 *	如果一定要立即终止连接，可以使用shutdown系统调用（相对于close来说，它是专门为网络编程设计的）
	 *
	 *	#include <sys/socket.h>
	 *	int shutdown(int sockfd, int howto);
	 *	其中howto决定了shutdown的行为，包括以下某个值：
     * +-------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------+
     * |  SHUT_RD    |  关闭sockfd上读的这一半，应用程序不能再针对socket文件描述符执行读操作，并且该socket接收缓冲区中的数据都被丢弃                                                      |
     * +-------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------+
     * |  SHUT_WR    |  关闭sockfd上写的这一半，sockfd的发送缓冲区中的数据会在真正关闭连接之前全部发送出去，应用程序不可再对该socket文件描述符执行写操作。这种情况下，连接处于半关闭状态  |
     * +-------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------+
     * |  SHUT_RDWR  |  同时关闭sockfd上的读和写                                                                                                                                          |
     * +-------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------+
	 */
	close(sockfd);
	return 0;
}