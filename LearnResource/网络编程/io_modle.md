# 高性能网络IO中的概念

## 讲在前面的概念
有几个概念必须先搞清楚：阻塞，非阻塞，同步，异步，并发，并行。
用一个打水故事来讲这几个概念，如果已有相关概念可以跳过。

阻塞：
我去打水，不管有没水有多少水，必须打满一桶水才能回寝室，期间不准干其他事儿

非阻塞：
我去打水，不管有没水有多少水，我尽力多打，打完水转身就走，然后该干啥就干啥去

同步：
我去打水，我走到门口，问开水房的大爷，它会告诉我开水房目前的状态，我再决定打不打、怎么打、打多少

异步： 我给了小侄儿10块钱，他去帮我打水，然后我自己该干啥干啥

并发：开水房只有一个水龙头，我和小侄儿一起进去，然后每放了200ml的水就换一个人，打满了一起出来

并行： 开水房有两个水龙头，我和小侄儿一人一个打水

阻塞和非阻塞的概念是对于调用某个函数的线程来说的，若函数一定要陷入内核而且等待io完成再返回，那么就是阻塞；若函数陷入内核只是尽力IO尽快返回，那么就是非阻塞。

同步和异步不太好解释。就我个人的理解来说，同步和异步的最核心的区别在于在于一个事件对另一个事件的把握。如果一个事件有途径获得另一个事件的状态，并能够影响或者根据对方的状态决定自己的行为，那就是同步；如果一个事件对另一个事件目前的状态完全是未知的或者不关心的，那么就是异步。
我觉得网上绝大部分解释都没有抓住重点。A事件如果对于B事件的状态是清楚的，那么A事件可以决定自己的行为，比如A事件要等待B事件发生完成之后才可以获得正确的结果，那么A事件一定会在自己真正开始之前不断的获得B事件的状态，直到达到自己的目的；而异步来说，A对B进行的状态是未知的，B事件可能获得一个命令——在完成之后通知A自己完成了。

并行是指同一个时刻内，两个事件同时发生；并发是指某一个时刻内，两个事件看起来像是同时发生一样，这个很好理解。

讲完这个，再来看看这前面两组概念混起来的时候，怎么解释。

同步阻塞:我去打水，我问大爷，我可以进去不？大爷说可以进去，我就进去；大爷说不可以进去，我就在原地等着，能进去的那一刻就直接冲进去，期间啥都不能干，等着。
同步非阻塞:我去打水，我问大爷，我可以进去不，大爷说可以进去，我就进去打水；大爷说不可以，我转身就走，隔会儿再过来问。
异步阻塞:我给了侄儿10块钱让他去打水，他说好，然后我就站在原地傻傻发呆，啥都不干，等着侄儿回来。（好傻…）
异步非阻塞:我给了侄儿10块钱让他去打水，告诉他，你打完了回来叫我哦，然后我就继续写博客了。

嗯，概念就讲完了~

## linux下IO多路复用的工具

接下来我们来看我们linux里面IO多路复用的工具：
select：
每次select时，拷贝fd信息进内核，排队，等待超时，遍历所有fd，默认为1024个
poll： select的优化版，提高效率，增大fd处理的上限
epoll：
更高级的优化，可以处理海量fd，回调通知，用户空间通过mmap和内核空间使用同一块内存
kqueue： freebsd上的事件通知接口（wiki），完成类似epoll的功能

值得一提的时，epoll的效率在某些情况下比select或者poll要低，这个是曾经做过测试的。具体的业务场景就是：几乎所有连接都处于活跃状态，并且有频繁的业务数据发送和接受，这个时候select或者poll的能力要强于epoll。
